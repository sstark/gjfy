package cmd

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"html/template"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"github.com/spf13/cobra"
	"github.com/sstark/gjfy/api"
	"github.com/sstark/gjfy/fileio"
	"github.com/sstark/gjfy/misc"
	"github.com/sstark/gjfy/store"
	"github.com/sstark/gjfy/tokendb"
)

const (
	myName                = "gjfy"
	defaultHostname       = "localhost"
	listenDefault         = ":9154"
	maxData               = 1048576 // 1MB
	expiryCheck           = 30      // minutes
	crtFile               = myName + ".crt"
	keyFile               = myName + ".key"
	TLSDefault            = false
	notifyDefault         = false
	allowAnonymousDefault = false
)

var (
	auth            tokendb.TokenDB
	css             []byte
	logo            []byte
	updated         = time.Time{}
	fListen         string
	fURLBase        string
	fTLS            bool
	fNotify         bool
	fAllowAnonymous bool
	scheme          = "http://"
	userMessageView string
)

type viewInfoEntry struct {
	store.StoreEntryInfo
	UserMessageView string
}

type jsonError struct {
	Error string `json:"error"`
}

func Log(handler http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		realRemoteAddr := misc.GetRealIP(r)
		log.Printf("%s (%s) \"%s %s %s\" \"%s\"", r.RemoteAddr, realRemoteAddr, r.Method, r.URL.Path, r.Proto, r.Header.Get("User-Agent"))
		handler.ServeHTTP(w, r)
	})
}

func getURLBase() string {
	if fURLBase != "" {
		return fURLBase
	}
	sl := strings.Split(fListen, ":")
	port := sl[len(sl)-1]
	return fmt.Sprintf("%s%s:%s", scheme, defaultHostname, port)
}

func updateFiles() {
	auth = tokendb.MakeTokenDB(fileio.TryReadFile(tokendb.AuthFileName))
	if auth == nil {
		log.Println("auth db could not be loaded, please fix and reload")
	}
	css = fileio.TryReadFile(fileio.CssFileName)
	logo = fileio.TryReadFile(fileio.LogoFileName)
	userMessageView = fileio.FileOrConst(fileio.UserMessageViewFilename, fileio.UserMessageViewDefaultText)
	updated = time.Now()
}

var rootCmd = &cobra.Command{
	Use:   "gjfy",
	Short: "gjfy short description",
	Long: `gjfy bla bla bla
                bla bla bla
                bla bla bla`,
	Run: func(cmd *cobra.Command, args []string) {
		flag.StringVar(&fListen, "listen", listenDefault, "listen on IP:port")
		flag.StringVar(&fURLBase, "urlbase", "", "base URL (will be generated by default)")
		flag.BoolVar(&fTLS, "tls", TLSDefault, "use TLS connection")
		flag.BoolVar(&fNotify, "notify", notifyDefault, "send email notification when one time link is used")
		flag.BoolVar(&fAllowAnonymous, "allow-anonymous", allowAnonymousDefault, "allow secrets by anonymous users")
		flag.Parse()

		log.Printf("gjfy version %s\n", misc.Version)

		memstore := make(store.SecretStore)
		memstore.NewEntry("secret", 100, 0, "test@example.org", "test")
		go memstore.Expiry(time.Minute * expiryCheck)

		updateFiles()

		sighup := make(chan os.Signal, 1)
		signal.Notify(sighup, syscall.SIGHUP)
		go func() {
			for {
				<-sighup
				log.Println("reloading configuration...")
				updateFiles()
			}
		}()

		tIndex := template.New("index")
		tIndex.Parse(fileio.HtmlMaster)
		tIndex.Parse(fileio.HtmlIndex)
		tView := template.New("view")
		tView.Parse(fileio.HtmlMaster)
		tView.Parse(fileio.HtmlView)
		tViewErr := template.New("viewErr")
		tViewErr.Parse(fileio.HtmlMaster)
		tViewErr.Parse(fileio.HtmlViewErr)
		tViewInfo := template.New("viewInfo")
		tViewInfo.Parse(fileio.HtmlMaster)
		tViewInfo.Parse(fileio.HtmlViewInfo)
		http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
			w.WriteHeader(http.StatusOK)
			type Data struct {
				AllowAnonymous bool
			}
			tIndex.ExecuteTemplate(w, "master", &Data{AllowAnonymous: fAllowAnonymous})
		})

		if fAllowAnonymous {
			http.HandleFunc(api.ApiCreate, func(w http.ResponseWriter, r *http.Request) {
				err := r.ParseForm()
				if err != nil {
					http.Error(w, err.Error(), http.StatusBadRequest)
					return
				}
				entry := memstore.NewEntry(r.Form.Get("secret"), 1, 7, "anonymous", "")
				w.Write([]byte(fmt.Sprintf("%s%s?id=%s", getURLBase(), api.Get, entry)))
			})
		}

		http.HandleFunc(api.ApiGet, func(w http.ResponseWriter, r *http.Request) {
			id := r.URL.Path[len(api.ApiGet):]
			w.Header().Set("Content-Type", "application/json; charset=UTF-8")
			if entry, ok := memstore.GetEntryInfo(id, getURLBase()); !ok {
				w.WriteHeader(http.StatusNotFound)
				log.Printf("entry not found: %s", id)
				if jerr := json.NewEncoder(w).Encode(jsonError{"not found"}); jerr != nil {
					panic(jerr)
				}
			} else {
				memstore.Click(id, r, fNotify)
				w.WriteHeader(http.StatusOK)
				if err := json.NewEncoder(w).Encode(entry); err != nil {
					panic(err)
				}
			}
		})

		http.HandleFunc(api.ApiNew, func(w http.ResponseWriter, r *http.Request) {
			var entry store.StoreEntry

			body, err := ioutil.ReadAll(io.LimitReader(r.Body, maxData))
			if err != nil {
				panic(err)
			}
			if err := r.Body.Close(); err != nil {
				panic(err)
			}
			w.Header().Set("Content-Type", "application/json; charset=UTF-8")
			if err := json.Unmarshal(body, &entry); err != nil {
				w.WriteHeader(422) // unprocessable entity
				log.Printf("error processing json: %s", err)
				if jerr := json.NewEncoder(w).Encode(jsonError{err.Error()}); jerr != nil {
					panic(jerr)
				}
			} else if !auth.IsAuthorized(&entry) {
				w.WriteHeader(http.StatusUnauthorized)
				log.Printf("unauthorized try to make new entry")
				if jerr := json.NewEncoder(w).Encode(jsonError{"unauthorized"}); jerr != nil {
					panic(jerr)
				}
			} else {
				id := memstore.AddEntry(entry, "")
				newEntry, _ := memstore.GetEntryInfoHidden(id, getURLBase())
				log.Println("New ID:", id)
				w.WriteHeader(http.StatusCreated)
				if err := json.NewEncoder(w).Encode(newEntry); err != nil {
					panic(err)
				}
			}
		})

		http.HandleFunc(api.Get, func(w http.ResponseWriter, r *http.Request) {
			id := r.URL.Query().Get("id")
			if entry, ok := memstore.GetEntryInfo(id, getURLBase()); !ok {
				w.WriteHeader(http.StatusNotFound)
				log.Printf("entry not found: %s", id)
				tViewErr.ExecuteTemplate(w, "master", nil)
			} else {
				memstore.Click(id, r, fNotify)
				w.WriteHeader(http.StatusOK)
				viewEntry := viewInfoEntry{entry, userMessageView}
				tView.ExecuteTemplate(w, "master", viewEntry)
			}
		})

		http.HandleFunc(api.Info, func(w http.ResponseWriter, r *http.Request) {
			id := r.URL.Query().Get("id")
			if entry, ok := memstore.GetEntryInfo(id, getURLBase()); !ok {
				w.WriteHeader(http.StatusNotFound)
				tViewErr.ExecuteTemplate(w, "master", nil)
			} else {
				w.WriteHeader(http.StatusOK)
				tViewInfo.ExecuteTemplate(w, "master", entry)
			}
		})

		http.HandleFunc(api.Fav, func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Content-Type", "image/x-icon")
			w.WriteHeader(http.StatusOK)
			w.Write(fileio.Favicon)
		})

		http.HandleFunc(api.LogoSmall, func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Content-Type", "image/png")
			w.WriteHeader(http.StatusOK)
			w.Write(fileio.GjfyLogoSmall)
		})

		http.HandleFunc(api.Css, func(w http.ResponseWriter, r *http.Request) {
			http.ServeContent(w, r, fileio.CssFileName, updated, bytes.NewReader(css))
		})

		http.HandleFunc(api.Logo, func(w http.ResponseWriter, r *http.Request) {
			http.ServeContent(w, r, fileio.LogoFileName, updated, bytes.NewReader(logo))
		})

		http.HandleFunc(api.ClientShell, func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Content-Type", "application/x-sh")
			w.WriteHeader(http.StatusOK)
			misc.ClientShellScript(w, getURLBase()+api.ApiNew)
		})

		if fNotify {
			log.Println("email notifications enabled")
		}

		if fTLS {
			scheme = "https://"
			cf := fileio.TryFile(crtFile)
			if cf == "" {
				log.Fatalf("unable to open %s\n", crtFile)
			}
			kf := fileio.TryFile(keyFile)
			if kf == "" {
				log.Fatalf("unable to open %s\n", keyFile)
			}
			log.Printf("using '%s' as URL base\n", getURLBase())
			log.Println("listening on", fListen, "with TLS")
			log.Fatal(http.ListenAndServeTLS(fListen, cf, kf, Log(http.DefaultServeMux)))
		} else {
			log.Printf("using '%s' as URL base\n", getURLBase())
			log.Println("listening on", fListen, "without TLS")
			log.Fatal(http.ListenAndServe(fListen, Log(http.DefaultServeMux)))
		}
	},
}

func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}
