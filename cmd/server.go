package cmd

import (
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"github.com/spf13/cobra"
	"github.com/sstark/gjfy/fileio"
	"github.com/sstark/gjfy/httpio"
	"github.com/sstark/gjfy/misc"
	"github.com/sstark/gjfy/store"
	"github.com/sstark/gjfy/tokendb"
)

const (
	myName                = "gjfy"
	defaultHostname       = "localhost"
	listenDefault         = ":9154"
	expiryCheck           = 30 // minutes
	crtFile               = myName + ".crt"
	keyFile               = myName + ".key"
	TLSDefault            = false
	notifyDefault         = false
	allowAnonymousDefault = false
)

var (
	auth            tokendb.TokenDB
	css             []byte
	logo            []byte
	updated         = time.Time{}
	fListen         string
	fURLBase        string
	fTLS            bool
	fNotify         bool
	fAllowAnonymous bool
	scheme          = "http://"
	userMessageView string
)

func Log(handler http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		realRemoteAddr := misc.GetRealIP(r)
		log.Printf("%s (%s) \"%s %s %s\" \"%s\"", r.RemoteAddr, realRemoteAddr, r.Method, r.URL.Path, r.Proto, r.Header.Get("User-Agent"))
		handler.ServeHTTP(w, r)
	})
}

func getURLBase() string {
	if fURLBase != "" {
		return fURLBase
	}
	sl := strings.Split(fListen, ":")
	port := sl[len(sl)-1]
	return fmt.Sprintf("%s%s:%s", scheme, defaultHostname, port)
}

func updateFiles() {
	auth = tokendb.MakeTokenDB(fileio.TryReadFile(tokendb.AuthFileName))
	if auth == nil {
		log.Println("auth db could not be loaded, please fix and reload")
	}
	css = fileio.FileOrFunc(fileio.CssFileName, func(fn string) []byte {
		// default to embedded css if file not found
		return fileio.CustomCss
	})
	logo = fileio.FileOrFunc(fileio.LogoFileName, func(fn string) []byte {
		// default to embedded logo if file not found
		return fileio.GjfyLogo
	})
	userMessageView = fileio.FileOrConst(fileio.UserMessageViewFilename, fileio.UserMessageViewDefaultText)
	updated = time.Now()
}

func init() {
	rootCmd.AddCommand(serverCmd)
	serverCmd.Flags().StringVarP(&fListen, "listen", "l", listenDefault, "Listen on IP:port")
	serverCmd.Flags().StringVarP(&fURLBase, "urlbase", "u", "", "Base URL (will be generated by default)")
	serverCmd.Flags().BoolVarP(&fTLS, "tls", "s", TLSDefault, "Use TLS connection")
	serverCmd.Flags().BoolVarP(&fNotify, "notify", "n", notifyDefault, "Send email notification when one time link is used")
	serverCmd.Flags().BoolVarP(&fAllowAnonymous, "allow-anonymous", "a", allowAnonymousDefault, "Allow secrets by anonymous users")
}

var serverCmd = &cobra.Command{
	Use:   "server",
	Short: "Run the main gjfy service",
	Long: `
The server subcommand starts the gjfy web service, listening and waiting for
users to retrieve secrets.

(This is the functionality of gjfy releases <=1.2, which has been moved
into the server subcommand)`,
	Run: func(cmd *cobra.Command, args []string) {
		log.Printf("gjfy version %s\n", Version)

		memstore := make(store.SecretStore)
		memstore.NewEntry("secret", 100, 0, "test@example.org", "test")
		go memstore.Expiry(time.Minute * expiryCheck)

		updateFiles()

		sighup := make(chan os.Signal, 1)
		signal.Notify(sighup, syscall.SIGHUP)
		go func() {
			for {
				<-sighup
				log.Println("reloading configuration...")
				updateFiles()
			}
		}()

		// View handlers
		http.Handle("/", httpio.HandleIndex(fAllowAnonymous))
		http.Handle(httpio.Get, httpio.HandleGet(memstore, getURLBase(), fNotify, userMessageView))
		http.Handle(httpio.Info, httpio.HandleInfo(memstore, getURLBase()))
		if fAllowAnonymous {
			http.Handle(httpio.Create, httpio.HandleCreate(memstore, getURLBase()))
		}

		// API handlers
		http.Handle(httpio.ApiGet, httpio.HandleApiGet(memstore, getURLBase(), fNotify))
		http.Handle(httpio.ApiNew, httpio.HandleApiNew(memstore, getURLBase(), auth))

		// Static handlers
		http.Handle(httpio.Fav, httpio.HandleStaticFav())
		http.Handle(httpio.LogoSmall, httpio.HandleStaticLogoSmall())
		http.Handle(httpio.Css, httpio.HandleStaticCss(css, updated))
		http.Handle(httpio.Logo, httpio.HandleStaticLogo(logo, updated))
		http.Handle(httpio.ClientShell, httpio.HandleStaticClientShellScript(getURLBase()))

		if fNotify {
			log.Println("email notifications enabled")
		}

		if fTLS {
			scheme = "https://"
			cf := fileio.TryFile(crtFile)
			if cf == "" {
				log.Fatalf("unable to open %s\n", crtFile)
			}
			kf := fileio.TryFile(keyFile)
			if kf == "" {
				log.Fatalf("unable to open %s\n", keyFile)
			}
			log.Printf("using '%s' as URL base\n", getURLBase())
			log.Println("listening on", fListen, "with TLS")
			log.Fatal(http.ListenAndServeTLS(fListen, cf, kf, Log(http.DefaultServeMux)))
		} else {
			log.Printf("using '%s' as URL base\n", getURLBase())
			log.Println("listening on", fListen, "without TLS")
			log.Fatal(http.ListenAndServe(fListen, Log(http.DefaultServeMux)))
		}
	},
}
